# Лабораторная 1
## Изучение инструментов профилирования и анализа производительности java-приложений
### Раздел:
Профилирование и тестирование производительности
### Описание: 
В данной лабораторной работе студентам предстоит реализовать один из изученных на предыдущих курсах алгоритмов или структур данных и выполнить анализ производительности полученного решения, а также серию оптимизаций алгоритма с точки зрения потребления памяти, ресурсов процессора и jit-а.
### Алгоритмы
- BFS
- DFS Recursive
- DFS Iterative

## BFS
### Код алгоритма
![img_2.png](src/main/img/img_2.png)
### Результаты работы Benchmark
![img_3.png](src/main/img/img_3.png)
### CPU Flame Graph
![img_4.png](src/main/img/img_4.png)
Как видно из графика, время тратится на обработку очереди (LinkedList.add и LinkedList.poll). Использование LinkedList может быть оптимизировано заменой на IntArrayList из fastutil или ArrayDeque, которая оптимизирована для операций добавления и удаления с начала очереди.
### Memory allocation
![img_5.png](src/main/img/img_5.png)
Самый большой вклад в использовании памяти связан с внутренними узлами LinkedList$Node и их связями (метод linkLast и создание новых объектов). 
Есть некоторая нагрузка на память, связанная с автоупаковкой примитивов int в объекты Integer.

Варианты оптимизации:

1) Заменить LinkedList на ArrayDeque
2) Использовать fastutil для работы с примитивами

![img_7.png](src/main/img/img_7.png)

## DFS Recursive
### Код алгоритма
![img_8.png](src/main/img/img_8.png))
### CPU Flame Graph
![img_10.png](src/main/img/img_10.png)

1) Высокй процент времени уходит на управление стеком и вызовы методов, что типично для рекурсивных алгоритмов
2) Итератор LinkedList добавляет дополнительную накладную стоимость при работе со списками соседей

### Memory allocation
![img_11.png](src/main/img/img_11.png)
Каждый рекурсивный вызов добавляет новый фрейм в стек

### Вывод
Заменим LinkedList на IntArrayList

## DFS Iterative
### Код алгоритма
![img_12.png](src/main/img/img_12.png)
### CPU Flame Graph
![img_13.png](src/main/img/img_13.png)
Основное время тратится на вызовы метода DfsIterative и работу с методом Collection.reverse
### Memory allocation
![img_14.png](src/main/img/img_14.png)
Память выделяется преимущественно для объектов Integer (автоупаковка) и операции Stack.push
### Вывод
1) Для работы с примитивами воспользуемся fastutil
2) Уйдем от использования дорогостоящего метода Collections.reverse. Хранить соседей в правильном порядке или итерировать в обратном порядеке.

## Класс Graph
![img_15.png](src/main/img/img_15.png)
Вместо LinkedList так же воспользуемся структурами данных из fastutil позволяющие работать с примитивами
### Обновленный код
![img_16.png](src/main/img/img_16.png)

## Оптимизация

## BFS

| **Алгоритм**            | **Изначальная структура данных**       | **Оптимизированная структура данных**       | **Преимущества улучшений**                                                    |
|-------------------------|----------------------------------------|---------------------------------------------|-------------------------------------------------------------------------------|
| **BFS**                | `LinkedList`            | `IntArrayList`             | Ускорение операций добавления/удаления, снижение накладных расходов.         |
| **BFS (посещённые узлы)** | `HashSet`                             | `IntOpenHashSet`                            | Уменьшение памяти за счёт работы с примитивами, быстрая проверка посещения (\(O(1)\)). |
| **DFS (рекурсивный)**   | `List<Integer>` для соседей            | `IntList`                                   | Исключение автоупаковки, снижение затрат на память, улучшение итерации.      |
| **DFS (итеративный)**   | `Stack<Integer>`                       | `IntArrayList`                              | Быстрые операции со стеком, работа с примитивами, снижение затрат на память. |
| **DFS (итерация соседей)** | `Collections.reverse` для реверса списка | Итерация в обратном порядке через индексы   | Устранены накладные расходы на реверсирование списка.                        |
| **DFS (посещённые узлы)** | `boolean[]`                           | `IntOpenHashSet`                            | Более эффективное использование памяти.                 |

---

### Результаты benchmark
![img_17.png](src/main/img/img_17.png)
Как можно заметить, результаты значительно улучшились
### BFS
### Код алгоритма
![img_18.png](src/main/img/img_18.png)
### CPU Flame Graph
![img_19.png](src/main/img/img_19.png)
Значительная часть времени тратится на операции с примитивными коллекциями, что ожидалось.
Так же значительно снизилось время алгоритма.
### Memory allocation
![img_20.png](src/main/img/img_20.png)
Потребление памяти значительно уменьшилось
### DFS Recursive
### Код алгоритма
![img_21.png](src/main/img/img_21.png)
### CPU Flame Graph
![img_22.png](src/main/img/img_22.png)
Основное время тратится на алгоритм + итератор intArrayList
### Memory allocation
![img_23.png](src/main/img/img_23.png)
Заметных изменений не обнаружилось
### DFS Iterative
### Код алгоритма
![img_24.png](src/main/img/img_24.png)
### CPU Flame Graph
![img_25.png](src/main/img/img_25.png)
Избавились времязатратного reverse, но общее время уменьшилось незначительно 
### Memory allocation
### Основное время теперь тратится на работу цикла
![img_1.png](src/main/img/img_1.png)
### Memory allocation
![img.png](src/main/img/img.png)
Основная занятая память теперь это int, но уменьшение потребления памяти незначительно.


